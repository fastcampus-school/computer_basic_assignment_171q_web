#과제 - 노용우

###2017년 1월 18일 수요일

##1. RAM은 어떤 단어들의 약자이며, 왜 RAM이라고 부르게 되었을까?
**R**andom **A**ccess **M**emory

_임의의 영역에 접근하여 읽고 쓰기가 가능_

> 어느 위치에 저장된 데이터든지 접근(읽기 및 쓰기)하는 데 동일한 시간이 걸리는 메모리이기 때문에 **Random** 이라는 명칭이 주어짐

##2. 하버드 구조와 폰 노이만 구조의 한계는 각각 무엇이며 지금은 어떻게 구성된 모습으로 사용되고 있을까?

####1. 하버드 구조의 한계
  * 당장 사용되지 않는 *free data memory* 를 효율적으로 관리하지 못함
  * 두 개의 *bus* 를 기반으로 하기 때문에 **시간과 비용**이 많이 들어감

####2. 폰 노이만 구조의 한계
  * 하나의 버스를 통한 순차적인 접근으로 인해 프로그램을 동시에 여러개 실행시킬 수 없으므로 **병행 실행을 위해서는 운영체제에서 별도로 구현해야 함**
  * 병목 현상이 발생하므로 오직 하나의 명령어만이 같은 시간에 접근이 가능

####3. 현재 모습
  * 현재는 하버드 방식과 폰 노이만 방식이 **둘 다 적용**되어 있음

> 일반적으로 사용되는 범용 프로세서는 물리적으로 봤을 때는 *Memory-controller* 가 *Instruction* 및 *Data memory* 와 각각의 *bus* 들을 잇기 때문에 **폰 노이만 방식**을 취하고 있으면서 *Instruction* 및 *Data Memory* 를 분리해서 사용하는 **하버드 방식**을 취하고 있음

> 어떤 종류의 *Micro-controller* 들은 추가적인 메모리를 하버드 구조로 *Instruction* 및 *data memory* 을 서로 분리해서 제공하고 있음

##3. 한글을 표현할 수 있는 문자 인코딩 방식에는 무엇이 있을까? 각각의 장단점도 조사해 보세요.

####1. 한글 표현 방법

조합형 | 완성형
--- | ---
한글의 제자 원리에 기반하여 초성, 중성, 종성에 각각 코드를 할당하는 방식 | '가', '각', '간'과 같은 완성된 문자에 코드를 할당하는 방식
N바이트 조합형, 2바이트 조합형, 3바이트 조합형 | 7비트 완성형, 2바이트 완성형

* 이 중 **완성형**이 한글 표준안으로 채택되었고, 따라서 유니코드의 한글 표현 방식에도 **완성형**이 먼저 채택되었음

####2. 한글의 인코딩 방식

EUC-KR | CP949(MS949)
---|---
KS X 1001과 KS X 1003 표준안의 인코딩 방식 | 확장 완성형의 인코딩 방식
2,350자의 한글 표현 가능 | 11,172자의 한글 표현 가능

* 단, Java에서는 CP949와 EUC-KR이 사실상 같으며, 확장 완성형을 사용하려면 MS949로 지정해야 함

####3. 유니코드

* 한글 완성형의 코드 포인트 범위는 U+AC00 ~ U+D7AF이므로, UTF-8 인코딩에서 한글은 무조건 3바이트 인코딩이다.

* 유니코드란?
   
   유니코드는 논리적으로 평면(plane)이라는 개념을 이용하여 구획을 나누며, 평면 개수는 0번 평면인 기본 다국어 평면에서 16번 평면까지 모두 17개이다. 대부분의 문자는 U+0000 ~ U+FFFF 범위에 있는 기본 다국어 평면에 속하며, 일부 한자는 보조 다국어 평면(SMP)인 U+100000 ~ U+1FFFF 범위에 속한다. 이중 한글은 U+1100 ~ U+11FF 사이에 한글 자모 영역, U+AC00 ~ U+D7AF 사이의 한글 소리 마디영역에 포함된다.

* 유니코드 인코딩 방식

   유니코드의 인코딩 방식으로는 코드 포인트를 코드화한 UCS-2와 UCS-4, 변환 인코딩 형식인 UTF-7, UTF-8, UTF-16, UTF-32 인코딩 등이 있다. 이 중 ASCII와 호환이 가능하면서 유니코드를 표현할 수 있는 UTF-8 인코딩이 가장 많이 사용된다.

<코드 포인트 범위 | 비트 수 | 인코딩
---|---|---
U+0000 ~ U+007F | 7 | 그대로 인코딩
U+0080 ~ U+07FF | 11 | 110xxxxx 10xxxxxx
U+0800 ~ U+FFFF | 16 | 1110xxxx 10xxxxxx 10xxxxxx
U+10000 ~ U+1FFFFF | 21 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

위의 표에서 xxxx로 표시된 부분에는 원래의 비트 값을 순서대로 적는다.

