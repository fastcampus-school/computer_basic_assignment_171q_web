**Comment: ctr+c/ctr+v는 지양합시다~**


### 버전관리

> 버전 관리(version control,revision control), 소스관리(source control), 소스 코드 관리(source code management, SCM)란 동일한 정보에 대한 여러 버전을 관리하는 것을 말한다. 공학과 소프트웨어 개발에서 팀 단위로 개발 중인 소스 코드나, 청사진 같은 설계도 등의 디지털 문서를 관리하는데 사용된다. 그러한 문서의 변경 사항들에 숫자나 문자로 이뤄진("개정판 번호"나 "개정판 레벨"이라고도 불리는) "버전"을 부여해서 구분한다. "버전"을 통해서 시간적으로 변경 사항과 그 변경 사항을 작성한 작업자를 추적할 수 있다. 간단한 버전 관리 방법으로는 처움 작성한 코드에 버전 번호 1을 부여한다. 변경 사항이 생기면, 버전 번호를 2로 증가시킨다. 이처럼 추후 변경 사항이 발생 시마다 버전 번호를 1씩 증가시킨다.

> 소프트웨어 엔지니어링에서는 일반적인 소프트웨어 소스 코드만을 관리하는  내역을 주로 버전 관리라고 정의하게 된다. 일반적으로 산업 공학이나 이전 생산 기반 제조 공학 등에서 소프트웨어 쪽으로 넘어오는 학문적 관심에 의해 이전 생산 공학에서 사용하던 개념을 가져오게 되었고, 그에 따라 버전 관리(Software Version Management)와 형상 관리(Software Configuration Management)의 개념들이 따라왔다고 볼 수 있겠다.

> 버전 관리를 이용해야하는 까닭
거의 대부분의 주요 소프트웨어 개발 프로젝트는 아직도 소프트웨어의 설계도라 할 수 있는 소스코드 작성이 주요한 부분이 되며 이러한 소스 코드는 기업체 또는 연구소의 핵심 역량이 응축된 핵심 자산이다. 따라서 어떤 형태로든 소스 코드를 백업하여 분실의 위험에서 보호하고 개정 전후 내용을 파악하여 추후 발생할지도 모를 오류 수정에 대비하는 절차가 필요하다. 버전 관리 소프트웨어는 조직의 핵심 자산인 소스 코드의 개정과 백업 절차를 자동화하여 오류 수정 과정을 도와줄 수 있는 시스템으로 이미 다수의 국제 협력 개방 소프트웨어 개발 실무에서도 널리 사용되고 있다.

>버전 관리 시스템을 사용하는 원인
>  * 무언가 잘못되었을 때 복구를 돕기 위하여
>  * 프로젝트 진행 중 과거의 어떤 시점으로 돌아갈 수 있게 하기 위하여
>  * 여러 사람이 같은 프로젝트에 참여할 경우, 각자가 수정한 부분을 팀원 전체가 동기화하는 과정을 자동화하기 위하여
>  * 소스 코드의 변경 사항을 추적하기 위하여
>  * 소스 코드에서 누가 수정했는지 추적하기 위하여
>  * 대규모 수정 작업을 더욱 안전하게 진행하기 위하여
>  * 가지내기(Branch)로 프로젝트에 영향을 최소화 하면서 새로운 부분을 개발하기 위하여
>  * 접붙이기(Merge)로 검증이 끝난 후 새로이 개발된 부분을 본류(trunk)에 합치기 위하여
>  * 많은 오픈 소스 프로젝트에서 어떠한 형태로든 버전 관리를 사용하고 있으므로
>  * 코드의 특정 부분이 왜 그렇게 쓰여졌는지 의미를 추적하기 위하여

_출처 : 위키백과_

---
### 버전관리 방법
  : 버전 관리는 보통 버전 관리 시스템을 이용하여 하는데, 대표적으로  Subversion, Mercurial, Git이 있다. 여기서는 일반적으로 버전 관리 소프트웨어가 사용되는 방식을 알아보겠다.
> * 갑돌이가 어떤 파일을 저장소(repository)에 추가(add)한다.
> * 추가되었던 파일을 갑돌이가 인출(Check out)한다.
> * 갑돌이가 인출된 파일을 수정한 다음, 저장소에 예치(Commit) 하면서 설명을 붙인다.
> * 다음날 을순이가 자신의 적업 공간을 동기화(Update)한다. 이때 갑돌이가 추가했던 파일이 전달된다.
> * 을순이가 추가된 파일의 수정 기록(Change log)을 보면서 갑돌이가 처음 추가한 파일과 이후 변경된 파일의 차이를 본다(Diff).

_출처 : 위키백과_

---

### Git 명령어
#### 기본적인 명령어

git --Version
현재 git의 버전을 확인한다

git init
현재 디렉토리에 git 저장소를 생성한다.

git add 파일명
git add는 2가지를 하는데 untracked files의 파일들을 git가 추적하도록 하거나 파일은 수정했지만 아직 스테이징 영역에 올라가지 않은(Changed but not updated)파일들을 스테이징 영역에 올린다. -i 옵션을 주면 대화형 모드가 시작되며 파일의 일부분만 선택해서 스테이징하는 것이 가능하다. -p 옵션을 사용하면 -i 대화형모드없이 바로 패치모드를 사용할 수 있다.

git commit -m "커밋메시지"
스테이징 영역에 올라가 있는 파일들을 커밋한다. -m은 커밋메시지를 주는 옵션으로 여러 줄의 커밋메시지를 쓸 경우 -m을 여러개 사용할 수 있다. -a 옵션을 사용하면 스테이징에 올리는 작업과 커밋을 동시에 할 수 있다.(추적되지 않는 파일은 추가하지 않는다.) -m을 사용하지 않을때 -v옵션을 사용하면 편집기에 커밋하려는 변경사항의 다른 점을 보여준다. 특정 파일만 커밋하려면 마지막에 파일명을 추가해주면 된다.

git commit -C HEAD -a --amend
지정한 커밋의 로그메시지를 다시 사용하여 기존 커밋을 수정한다. -c를 사용하면 기존 메시지를 수정할 수 있는 편집기를 실행해 준다.

git status
커밋되지 않은 변경사항을 조회한다.

git diff
스테이징 영역과 현재 작업트리의 차이점을 보여준다. --cached 옵션을 추가하면 스테이징 영역과 저장소의 차이점을 볼 수 있다. git diff HEAD를 입력하면 저장소, 스테이징 영역, 작업트리의 차이점을 모두 볼 수 있다. 파라미터로 log와 동일하게 범위를 지정할 수 있으며 --stat를 추가하면 변경사항에 대한 통계를 볼 수 있다.

git mv 파일명 새파일명
기존에 존재하는 파일을 새파일로 이동한다. 변경이력은 그대로 유지한다.

git checkout --파일명
아직 스테이징이나 커밋을 하지 않은 파일의 변경내용을 취소하고 이전 커밋 상태로 돌린다. svn에서 revert와 동일하다.

---
#### Branch와 TAG

git Branch
현재 존재하는 브랜치를 조회한다. -r옵션을 사용하면 원격 저장소의 브랜치를 확인할 수 있다.

git branch 브랜치명B 브랜치명A
브랜치명A에서 새로운 브랜치 브랜치명 B를 만든다.(git에서 기본 브랜치는 master라는 이름을 사용한다.)

git branch -d 브랜치명
브랜치를 삭제한다.

git branch -m 존재하는 브랜치명 새로운 브랜치명
존재하는 브랜치를 새로운 브랜치로 변경한다. 이미 존재하는 브랜치명이 있을 경우에는 에러가 나는데 -M옵션을 사용하면 이미 있는 브랜치의 경우에도 덮어쓴다.

git tag 태그명 브랜치명
브랜치명의 현재시점에 태그명으로 된 태그를 붙힌다. git tag만 입력하면 현재 존재하는 태그 목록을 볼 수 있다.

git checkout 브랜치명/태그명
해당 브랜치나 태그로 작업트리를 변경한다.

git checkout -b 브랜치명B 브랜치명A
브랜치명 A에서 브랜치명B라는 새로운 브랜치를 만들면서 체크아웃을 한다.

git rebase 브랜치명
브랜치명의 변경사항을 현재 브랜치에 적용한다.

git merge 브랜치명
브랜치명의 브랜치를 현재 브랜치로 합친다. --squash옵션을 주면 브랜치명의 모든 커밋을 하나의 커밋으로 만든다.

git cherry-pick 커밋명
커밋명의 특정 커밋만을 선택해서 현재 브랜치에 커밋으로 만든다. -n옵션을 주면 작업트리에 합치지만 커밋은 하지 않기 때문에 여러개의 커밋을 합쳐서 커밋할 수 있다.

---
#### 로그 관리

git log
커밋 로그들을 볼 수 있으며 -1나 -2같은 옵션을 주어 출력할 커밋로그의 갯수를 지정할 수 있다. --pretty=online옵션을 주면 한 줄로 간단히 보여주고 --pretty=format:%h%s"처럼 형식을 정해줄 수 있다.

git log 커밋명
해당 커밋명의 로그를 볼 수 있다.

git blame 파일명
갈 줄 앞에 커밋명과 커밋한 사람 등의 정보를 볼 수 있다.

git blame -L 10,15 파일명
-L 옵션을 사용하면 10줄부터 15줄로 범위를 지정해서 볼 수 있고 15대신 +5와 같이 사용할 수 있다.

git blame -M 파일명
-M 옵션을 사용하면 반복되는 패턴을 찾아서 복사하거나 이동된 내용을 찾아준다.

git revert 커밋명
기존의 커밋에서 변경한 내용을 취소해서 새로운 커밋을 만든다. -n옵션을 사용하면 바로 커밋하지 않기 때문에 revert를 여러번한 다음에 커밋할 수 있다.(항상 최신의 커밋부터 revert해야 한다.)

git reset 커밋명
이전 커밋을 수정하기 위해서 사용한다. --soft옵션을 사용하면 이전 커밋을 스테이징하고 커밋은 하지 않으며 --hard옵션은 저장소의 작업트리에서 커밋을 제거한다. git reset HEAD^와 같이 입력하면 최근 1개의 커밋을 취소할 수 있다.

git rebase -i 커밋범위
-i옵션으로 대화형모드로 커밋 순서를 변경하거나 합치는 등의 작업을 할 수 있다.

---
#### 원격 저장소

git clone 저장소 주소 폴더명
원격 저장소를 복제하여 저장소를 생성한다. 폴더명을 생략 가능하다.

git fetch
원격 저장소의 변경사항을 가져와서 원격 브랜치를 갱신한다.

git pull
git fetch에서 하는 원격 저장소의 변경사항을 가져와서 지역 브랜치에 합치는 작업을 한꺼번에 한다.

git push
파라미터를 주지 않으면 origin저장소에 푸싱하며 현재 지역브랜치와 같은 이름의 브랜치에 푸싱한다. --dry-run옵션을 사용하면 푸싱된 변경사항을 확인할 수 있다.

git remote add 이름 저장소주소
새로운 원격 저장소를 추가한다.

git remote
추가한 원격 저장소의 목록을 확인할 수 있다.

git remote show 이름
해당 원격 저장소의 정보를 볼 수 있다.

git remote rm 이름
원격저장소를 제거한다.

---
#### 서브모듈

git submodule
연관된 하위 모듈을 확인할 수 있다.

git submodule add 저장소주소 서브모듈 경로
새로운 하위 모듈을 해당 경로에 추가한다. 추가만하고 초기화하지는 않으며 커밋해쉬 앞에 (-)표시가 나타난다.

git submodule init 서브 모듈 경로
서브 모듈을 초기화 한다.

git submodule update 서브 모듈 경로
서브 모듈의 변경 사항을 적용한다.(저장소의 최신 커밋을 추적하지 않는다.)
